(define-macro (push v s)
  (unless (symbol? s) (error))
  `(begin (set! ,s (cons ,v ,s)) ,s))

(define (foldr f l)
  (cond ((null? l) '())
        ((null? (cddr l)) (f (car l) (cadr l)))
        (#t (f (car l) (foldr f (cdr l))))))

(define (list* . p) (foldr cons p))

; a la j: x f&g y ←→ (f x) g (f y)
; hence, ((& f g) x y z...) ←→ (f (g x) (g y) (g z)...)
(define (compose f g) (lambda args (apply f (map g args))))
; and here: x (f g) y ←→ x f g y
; ((hook f g) x y) ←→ (f x (g y))
(define (hook f g) (lambda (x y) (f x (g y))))
; in particular, cl (higher-order-fn :pred f :key g)
; can be expressed here using simply (higher-order fn :pred (hook f g))
(define (bind f . rest) (lambda args (apply f (append rest args))))
(define (rbind f . rest) (lambda args (apply f (append args rest))))

(define (filter f xs)
  (cond
    ((null? xs) '())
    ((f (car xs)) (cons (car xs) (filter f (cdr xs))))
    (#t (filter f (cdr xs)))))
(define (any f l) (not (null? (filter f l))))

(define (constantly val)
  (lambda - val))

(define (identity x) x)

(define (remove-duplicates l pred)
  (let ((ret '()))
    (let loop ((l l))
      (unless (null? l)
        (unless (any (lambda (x) (pred x (car l))) ret)
          (push (car l) ret))
        (loop (cdr l))))
    (reverse ret)))

(define (remove-duplicates-from-end l pred)
  (let ((ret '()))
    (let loop ((l l))
      (unless (null? l)
        (loop (cdr l))
        (unless (any (lambda (x) (pred x (car l))) ret)
          (push (car l) ret))))
    ret))

(define (every f l)
  (if (null? l)
    #t
    (and (f (car l))
         (every f (cdr l)))))

; to make up for multiple-value-bind
(define-macro (pidgin-destructuring-bind spec var . body)
  (let ((v (gensym)))
    (letrec ((expand (lambda (spec)
                       (if (null? spec)
                         `((unless (null? ,v) (error "too many values specified for destructuring")))
                         (list* `(set! ,(car spec) (car ,v))
                                `(set! ,v (cdr ,v))
                                (expand (cdr spec)))))))
      `(let ((,v ,var)
             ,@(map (lambda (s) `(,s #f)) spec))
         ,@(expand spec)
         ,@body))))

; simple stub generics implementation (single dispatch only)
; (defgeneric m (x y z))  will define a function 'm' that expects 'x' to be a
; let containing a bound lambda 'm'; y and z will be passed to that lambda
;
; (defgeneric* m (x y z) body) is similar, except that if the binding is
; missing, body will be evaluated instead
(define-expansion (defgeneric name pspec)
  `(define (,name ,@pspec)
     ((,(car pspec) ',name) ,@pspec)))

(define-expansion (defgeneric* name pspec . body)
  `(define (,name ,@pspec)
     (if (undefined? (,(car pspec) ',name))
       (begin ,@body)
       ((,(car pspec) ',name) ,@pspec))))

(define *classes* (make-hash-table 8 eq?))

(define-expansion (defclass name super slots . methods)
  (when (*classes* name) (error "Class already defined: ~a" name))
  (let* ((super (map (lambda (s) (let ((r (*classes* s))) (unless r (error "No superclass ~a" s)) r)) super))
         (auxiliary-slots   (apply append (map (lambda (c) (c 'all-slots)) super)))
         (auxiliary-methods (apply append (map (lambda (c) (c 'all-methods)) super)))
         (methods (map (lambda (m) `(,(car m) (lambda* ,(cadr m) ,@(cddr m)))) methods))
         (slots (map (lambda (s) (if (pair? s) s `(,s (error ,(format #f "No initializer supplied for slot ~a" s))))) slots))
         (accessor-methods '())
         (parm.bind (let* ((parm '())
                           (bindings '())
                           (dostuff (lambda (inherited p)
                                      (let ((s (symbol->string (car p))))
                                        (if (char=? (s 0) #\%)
                                          (let ((ns (string->symbol (substring s 1))))
                                            (push (list ns (cadr p)) parm)
                                            (push (list (car p) ns) bindings)
                                            (unless inherited
                                              (push (let ((v (gensym))) `(,ns (lambda (,v) (,v ',(car p))))) p)))
                                          (push p parm))))))
                      (map (bind dostuff #f) slots)
                      (map (bind dostuff #t) (filter (compose not (rbind member slots (compose eq? car))) auxiliary-slots))
                      (cons (reverse parm) (reverse bindings))))
         (all-slots (remove-duplicates-from-end `(,@auxiliary-slots ,@slots) (compose eq? car)))
         (all-methods (remove-duplicates-from-end `(,@auxiliary-methods ,@accessor-methods ,@methods) (compose eq? car))))
    ; for some reason returning multiple values here doesn't work?
    `(with-let (rootlet)
       (set! (*classes* ',name)
             (let ((all-slots ',all-slots)
                   (all-methods ',all-methods)
                   (class-name ',name)
                   (class-of #f)
                   (make (lambda* ,(car parm.bind)
                           (let (,@(cdr parm.bind)
                                  ,@all-methods)
                             (curlet)))))
               (curlet)))
       (set! ((*classes* ',name) 'class-of) (*classes* ',name))
      ,(let ((p (gensym)))
         `(define (,(string->symbol (format #f "make-~a" name)) . ,p)
            (apply ((*classes* ',name) 'make) ,p))))))
(define (make-instance what . p)
  (apply ((*classes* what) 'make) p))
